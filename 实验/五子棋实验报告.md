# Gobang 2023！
### Content：
* 游戏规则与产品外观
* 前期准备工作
* 主要封装函数
* 整体思路 && 关键实现代码
* 创新点（磨的时间比较长的突破口）
* 参考资料及文献
* 思考与感悟
* 游玩体验与棋力评估
***
### 游戏规则与产品外观
  Gobang 2023 可以进行如下操作：  
  Menu提示栏：可以选择PVP对战和人机对战，人机对战中还可以选择先手和后手，其中先手执黑后手执白。  
  Regret：进行悔棋操作，人机各悔棋一步  
  落子提示：为了使最后一颗落子更加醒目，会在中间出现绿点提醒。
  为了保持游戏的可玩性，并没有设置禁手  
  如果游戏胜负已定，在游戏的最后会弹出消息框判定胜负。  
  ![image](https://user-images.githubusercontent.com/113416659/218237949-0e5effa1-41d8-4646-8d87-b4fb950de6f1.png)  
  以下是一盘棋的全局：
  ![image](https://user-images.githubusercontent.com/113416659/218239650-6f12a265-dea8-47ea-b861-30ba88d4f6d3.png)  

***
### 前期准备工作
前期准备工作分为理论技术准备和基本思路，基本思路比较复杂，会在之后的章节中单独进行报告。  
本实验项目采用了EasyX的图形化界面，emmm因为是第一次使用GUI，所以对EasyX的一些语法会非常陌生，同时由于ide与EasyX的语法不完全兼容，因此需要不断调整属性，在游玩之前需要先将属性中的字符集进行修改，修改如下：  
![image](https://user-images.githubusercontent.com/113416659/218244840-9de398d6-60e5-48fe-97a6-419a6c3bad5c.png)
***
### 主要封装函数
![image](https://user-images.githubusercontent.com/113416659/218244862-0c992d25-27c0-4895-8903-a373dba3413e.png)
<br/>
![image](https://user-images.githubusercontent.com/113416659/218245117-f39e002d-8593-4049-8f66-57ead197dfb8.png)
<br/>
![image](https://user-images.githubusercontent.com/113416659/218245305-6d4d1d7e-7c9b-4289-bcc0-de30e058e717.png)
<br/>
![image](https://user-images.githubusercontent.com/113416659/218245451-ece428eb-9bc9-4d29-be5b-dc4a4d156fd9.png)
<br/>
***
### 整体思路 && 关键实现代码
我们都知道α-β剪枝是基于建立好数据树的基础之上的，那么数据树的建立，也就是评分函数和棋形的获取便十分重要，在初步利用Point结构体建立了一系列简单函数之后，可以得到电脑和人类落子的备用点集合。所以在这里使用了Move结构体，将除了刚刚落下的棋子之外的所有空位全部进行棋形分析和评分，储存之后便形成了初步数据树。这也就是InspireFind函数的作用。  
而在AI走子的分析过程中，我将分析过程分成了两部分：第一部分为算杀，即找到可以一击制胜的方式，算杀深度视杀点（分值高于500000）的数量而定，数量大于八个点则深度为8，否则算杀深度为12层。
第二部分为算杀失败，即当前局势并无一击制胜的最优解，则选择极大极小值搜索，选择评分最高的走法。  
在这里，算杀部分分为两个对称的函数，即maxKill与minKill，这种算杀方式实际上类似于攻防模式，由于我们采用了比较灵活的displayBoard方式，因此可以在棋盘上不显示走子的情况下模拟落子，如果某种算杀方式可以被玩家防御，那么就停止算杀，进入到下一个杀点的验证。killSearch函数与maxKill的代码部分很类似，但他的作用更像是一个算杀部分的控制台，通过KillSearch函数可以变更算杀的深度，同时还可以将算杀成功后的aix与aiy传回主函数中。  
```
int maxKill(int depth, Point p) {
    if (JudgeFive(p.x, p.y))//玩家落子成五
        return 0;
    if (depth == 0)//到最深仍未杀棋成功
        return 0;
    Move kill[100];
    int length = findComKill(kill);
    if (length == 0)
        return 0;
    for (int i = 0; i < length; i++) {
        put(kill[i].p, id);
        int killed = minKill(depth - 1, kill[i].p);
        unPut(kill[i].p);
        if (killed) {//在下一层杀棋成功
            return 1;
        }
    }
    return 0;
}
```
